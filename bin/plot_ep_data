#!/usr/bin/env python
import sys
import glob

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot
import matplotlib.colors
import matplotlib.cm

import numpy

from glue.segments import segment

def plot_tf_map(data, fname, data_segment, bandwidth, logscale=None, interp="nearest", ts=None, transform=None):
    pyplot.figure(2)
    pyplot.clf()
    #print fname, numpy.abs(data).max()
    if ts is not None:
        data_segment = (ts[0], ts[-1] + ts[1] - ts[0])

    if logscale is None:
        if transform:
            pyplot.imshow(transform(data[::-1]), extent=(0, data_segment[1]-data_segment[0], bandwidth[0], bandwidth[-1]), interpolation=interp, aspect='equal')
						
            # I can't get this to work. I suspect it has something to do with
            # the plot coordinates vs the data, but nothing I do seems to make
            # a difference.
            """
            ts = numpy.linspace(data_segment[0], data_segment[1], len(data[0]))
            freq = numpy.log10(numpy.linspace(bandwidth[0], bandwidth[1], len(data)))
            from matplotlib.image import NonUniformImage
            ax = pyplot.gca()
            im = NonUniformImage(ax, extent=(data_segment[0], data_segment[1], freq[0], freq[-1]), interpolation='nearest')
            im.set_data(ts, freq, data)
            ax.images.append(im)
            """
        else:
            pyplot.imshow(data[::-1], extent=(0, data_segment[1]-data_segment[0], bandwidth[0], bandwidth[-1]), interpolation=interp, aspect='equal')

        # Hack to force equal aspect
        ax = pyplot.gca()
        ex = ax.get_images()[0].get_extent()
        ax.set_aspect(abs((ex[1]-ex[0])/(ex[3]-ex[2])))

    else:
        ts = numpy.linspace(data_segment[0], data_segment[1], len(data[0]))-data_segment[0]
        freq = numpy.linspace(bandwidth[0], bandwidth[-1], len(data))
        if transform:
            pyplot.pcolormesh(ts, freq, transform(data))
        else:
            pyplot.pcolormesh(ts, freq, data)

        if 'y' in logscale:
            ax = pyplot.gca()
            ax.set_yscale('log')
        if 'x' in logscale:
            ax = pyplot.gca()
            ax.set_xscale('log')

    ax = pyplot.gca()
    ax.set_xlim(0, data_segment[1]-data_segment[0])
    ax.set_ylim(bandwidth[0], bandwidth[-1])

    pyplot.xlabel("time (s), relative to %10.5f" % data_segment[0])
    pyplot.ylabel("frequency (Hz)")
    pyplot.colorbar()
    pyplot.savefig(fname)

def stack_plot(time, data, lowf=0.0, highf=1.0):

    norm = matplotlib.colors.Normalize(lowf, highf)
    colormap = matplotlib.cm.ScalarMappable(norm=norm, cmap=matplotlib.cm.hsv)

    pyplot.figure()
    sum_across_t = numpy.abs(data**2).cumsum(axis=0).T
    for i, t_slice in enumerate(sum_across_t):
        sum_across_t[i] = numpy.sqrt(t_slice / t_slice[-1])
    sum_across_t = sum_across_t.T

    # First is special
    pyplot.fill_between(time, sum_across_t[0], color=colormap.to_rgba(lowf))

    i = 1.0
    for t_slice_lower, t_slice_upper in zip(sum_across_t[:-1], sum_across_t[1:]):
        pyplot.fill_between(time, t_slice_lower, t_slice_upper, color=colormap.to_rgba(i/sum_across_t.shape[0]*highf))
        i += 1
    colormap.set_array([lowf, highf])
    cb = pyplot.colorbar(colormap)
    cb.set_label("Filter low frequency")

    pyplot.xlim( (ts[0], ts[-1]) )
    pyplot.xlabel("time (s), relative to %10.5f" % ts[0])
    pyplot.savefig("fir_bank.png")

scan_data = numpy.load(sys.argv[1])

#
# Plot input data time stream
#

data_segment = segment(map(float, scan_data["segment"]))
bandwidth = segment(map(float, scan_data["bandwidth"][:2]))
base_band = scan_data["bandwidth"][-1]

print "Data segment: %s\nsearch band: %s (%f Hz channels)" % (str(data_segment), str(bandwidth), base_band)

# Readjust upper frequency
band = abs(bandwidth)
band /= base_band
highf = bandwidth[0] + int(band)*base_band
bandwidth = segment(bandwidth[0]+base_band/2, highf-base_band/2)

ts, d = scan_data["time_series"].T
ts -= data_segment[0]

# TODO: Zoom on certain gps time
# TODO: triple zoom plots?
# TODO: D3.js enabled?
pyplot.figure(0)
pyplot.plot(ts, d, 'k-')
pyplot.grid()
pyplot.xlabel("time (s), relative to %10.5f" % data_segment[0])
pyplot.ylabel("strain")
pyplot.savefig("input_data.png")

# in case memory is a problem
del ts, d

#
# Plot whitened data time stream
#

pyplot.twinx()
ts, d = scan_data["white_series"].T
ts -= data_segment[0]

pyplot.plot(ts, d, 'r-')
pyplot.grid()
pyplot.xlabel("time (s), relative to %10.5f" % data_segment[0])
pyplot.ylabel("whitened strain")
pyplot.xlim((0, abs(data_segment)))
pyplot.savefig("input_data.png")
#pyplot.savefig("white_data.png")

#
# Plot FIR processed data
#

d = scan_data["filter_series"].T
ts, d = d[0], d[1:]
#ts -= data_segment[0]
stack_plot(ts, d, bandwidth[0], bandwidth[1])

plot_tf_map(d, "fir_data.png", data_segment, bandwidth, ts=ts)

# norm fir_data
#d *= 0.044194

# simulate undersampling
#d = d.T[::2**5].T
#ts = ts[::2**5]
#plot_tf_map(d**2, "us_fir_data.png", data_segment, bandwidth)

#del ts, d

#
# Find all TF maps saved
#
for key in filter(lambda s: "sq_sum_series_" in s, scan_data.files):
    print key
    d = scan_data[key].T
    ts, d = d[0], d[1:]
    #ts -= data_segment[0]
    plot_tf_map(d, key + ".png", data_segment, bandwidth, ts=ts)
    del ts, d

#
# Make webpage
#
import os
from glue import cbcwebpage

if not os.path.exists("scan/"):
    os.makedirs("scan/")
os.chdir("scan/")
page = cbcwebpage.cbcpage(title="ExcessPower TF Scan", path="./")

subp = page.add_subpage("overview", "ExcessPower Scan Overview", "ExcessPower Scan Overview")

#subp.add_text(txt="GPS segment: %10.2f -- %10.2f" % (gps_start, gps_end))
# TODO: Channel
#Reference channel: %s <br/>
subp.div("""
<big><b>
GPS segment (s): %10.6f -- %10.6f <br/>
Search band (Hz): %4.4f -- %4.4f <br/>
</b></big>
""" % (data_segment[0], data_segment[1], bandwidth[0], bandwidth[1]))

ts_data = page.add_subpage("ts_data", "Time Series Data", "Time Series Data")
ts_sec = ts_data.add_section("ts_data_1", "Time Series")
imgtab = cbcwebpage.image_glob("../input_data.png")
cap = "Time series data"
cap1 = "Black shows the input time series, and red is the whitened time series."
ts_sec.add_table(imgtab, cap, cap1)

fir_data = page.add_subpage("fir_data", "Filter Response", "Filter Response Data")

fir_sec = fir_data.add_section("fir_data_1", "Filter Response")
imgtab = cbcwebpage.image_glob("../fir_data.png")
cap = "Filter response"
cap1 = "Filter response over each channel in the bank, color representing the magnitude of the convolution of the filter with the data stream."
fir_sec.add_table(imgtab, cap, cap1)

fir_sec = fir_data.add_section("fir_data_2", "Filter Band Energy Contribution")
imgtab = cbcwebpage.image_glob("../fir_bank.png")
cap = "Filter bank energy division"
cap1 = "Color corresponds to low frequency of channel. Height of channel color (time slice) is indicative of its proportion of energy contribution for that sample."
fir_sec.add_table(imgtab, cap, cap1)

sq_sum_data = page.add_subpage("sq_sum_data", "Energy TF Maps", "Energy TF maps")
i = 0
while True:
    band = base_band*2**(i+1)
    # FIXME: Do this right
    if not glob.glob("../sq_sum_series_level_%d_dof_*.png" % i):
        break
    sq_sum_sec = sq_sum_data.add_section("sq_sum_level_%d" % i, "Energy TF maps (bandwidth: %1.3g Hz)" % band)
    imgtab = cbcwebpage.image_glob("../sq_sum_series_level_%d_dof_*.png" % i)
    i += 1
    cap = "Energy map for TF resolution (NxM)"
    cap1 = "Color corresponds to energy of a given tile."
    sq_sum_sec.add_table(imgtab, cap, cap1)

import glob
flist = glob.glob("../L1-*.xml.gz")
if flist:
    trig_info_data = page.add_subpage("trig_info_data", "Trigger Table", "Trigger Info")

# Merge XML docs into one
from glue.ligolw.utils import ligolw_add, print_tables
from glue.ligolw import utils, lsctables
if len(flist) > 1:
    xmldoc = utils.load_filename(flist[0])
    ligolw_add.ligolw_add(xmldoc, flist[1:])

trig_info_sec = trig_info_data.add_section("trig_info", "Trigger Table")

"""
with open("triggers.txt", "w") as fout:
    trig_table = print_tables.print_tables(xmldoc, fout, "wiki", tableList=[lsctables.SnglBurstTable.tableName], title="SnglBurst triggers", columnList=["channel", "snr", "peak_time", "peak_time_ns", "duration", "central_freq", "bandwidth", "chisq_dof"])
ttable, name = cbcwebpage.wiki_table_parse("triggers.txt")

trig_info_sec.add_table(ttable[0], "Trigger table", "Table of trigger information. Channel indicates the channel analyzed, peak_time and peak_time_ns are the seconds and nanosecond field of the central time for each tile, duration is the width of the tile in the time domain, central frequency is the center frequency of the tile, bandwidth is the width of the tile in the frequency domain, and chisq_dof is the number of degrees of freedom present in that tile.")
"""

trig_info_sec.div("<br />Full Results XML<br />")
for file in flist:
    trig_info_sec.add_link(text="%s" % file, href=file)
    trig_info_sec.div("<br />")

if os.path.exists("../trigmap.png"):
    trig_map_data = page.add_subpage("trig_map_data", "Trigger Maps", "Trigger Maps")
    trig_map_sec = trig_map_data.add_section("trigmap", "Trigger TF maps")
    imgtab = cbcwebpage.image_glob("../trigmap.png")
    cap = "Trigger map"
    cap1 = "Color corresponds to SNR."
    trig_map_sec.add_table(imgtab, cap, cap1)

page.write("index")
